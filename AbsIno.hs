

module AbsIno where

-- Haskell module generated by the BNF converter




newtype Ident = Ident String deriving (Eq, Ord, Show, Read)
data Program = ProgramS [TopDef]
  deriving (Eq, Ord, Show, Read)

data TopDef = FnDef Type Ident [Arg] Block
  deriving (Eq, Ord, Show, Read)

data Arg = ValueArg Type Ident | RefArg Type Ident
  deriving (Eq, Ord, Show, Read)

data Block = BlockS [Stmt]
  deriving (Eq, Ord, Show, Read)

data Stmt
    = Empty -- DONE
    | Break
    | Continue
    | BStmt Block -- DONE
    | Decl Type [Item] -- DONE
    | Ass Ident Expr -- DONE
    | AssArrTupl Ident [Integer] Expr
    | Incr Ident -- DONE
    | Decr Ident -- DONE
    | Ret Expr
    | VRet
    | Cond Expr Stmt -- DONE
    | CondElse Expr Stmt Stmt -- DONE
    | While Expr Stmt -- DONE
    | For Type Ident Expr Expr Expr Stmt -- DONT NEED
    | SExp Expr -- DONE
  deriving (Eq, Ord, Show, Read)

data Item
    = NoInit Ident | Init Ident Expr | InitArr Ident Type [Integer]
  deriving (Eq, Ord, Show, Read)

data Type
    = Int -- DONE
    | Str -- DONE
    | Bool -- DONE
    | Void -- DONE
    | Array Type
    | Tuple [Type]
    | Fun [TypeA] Type
  deriving (Eq, Ord, Show, Read)

data TypeA = TypeArg Type | TypeArgR Type
  deriving (Eq, Ord, Show, Read)

data Expr
    = EVar Ident -- DONE
    | EArr Ident [Integer]
    | EMakeTuple [Type] [Expr]
    | EMethod Ident Ident -- DONT NEED
    | ELambda [Arg] Type Stmt
    | ELitInt Integer -- DONE
    | ELitTrue -- DONE
    | ELitFalse -- DONE
    | EApp Ident [Expr] -- MOCKED
    | EString String -- DONE
    | Neg Expr -- DONE
    | Not Expr -- DONE
    | EMul Expr MulOp Expr -- DONE
    | EAdd Expr AddOp Expr -- DONE
    | ERel Expr RelOp Expr -- DONE
    | EAnd Expr Expr -- DONE
    | EOr Expr Expr -- DONE
  deriving (Eq, Ord, Show, Read)

data AddOp = Plus | Minus
  deriving (Eq, Ord, Show, Read)

data MulOp = Times | Div | Mod
  deriving (Eq, Ord, Show, Read)

data RelOp = LTH | LE | GTH | GE | EQU | NE
  deriving (Eq, Ord, Show, Read)

